Index (索引) in Database (PostgreSQL 為例)



# Index 介紹 (What)


( 無 Index) <br>
使用資料庫時，我們常常會需要去資料庫裡面查詢資料，一般情況下，資料庫預設是全局掃描，也就是說從第一筆到最後一筆都看過後，將符合需求的回傳給使用者。但是如果今天資料筆數有 1000萬筆呢? 

`掃描1000萬筆資料之後才回傳，速度會非常慢，對吧!` 

這時候大家就想出一個方法來提升查詢速度，那就是 Index 。

主要方法就是讓資料庫 `不必每次從頭掃描` 整個資料表，而是透過 Index 快速定位資料位置。因此大家介紹時都會將 Index 比喻成 "書本的目錄"，資料是用 `查詢` 的而不是`一個一個搜尋` 

**Index 核心理念 :  "加速資料查詢"**

# Index 使用時機 (When)

1. 頻繁查詢的欄位 : 
    - 包含搜尋條件 `(select..from.. where,,)`
    - 查詢整張表就不需要 `(select * from table;)`
2. 資料量龐大 : 如前面介紹，要避免1000萬筆資料都看過才能回傳
3. 常用作排序或分組的欄位 (OrderBy, GroupBy) : 省去排序的時間

不適用的時機 : 

1. 頻繁寫入的欄位或表 : 索引也是需要維護的，一直修修改改會造成額外許多成本
2. 小型資料表 : 速度本來就快，不需要額外維護索引。
3. 低選擇性欄位 : 例如Boolean欄位、少量不同值的欄位，效果很差



# Index 實踐原理 (How)

為甚麼透過 Index 就可以讓資料庫從全局掃描，變成是像目錄般的查詢呢? 工程師應該都知道

- 要空間 ? 那你就要放棄時間
- 要時間 ? 那你就要放棄空間

所以 Index 實際上就是要額外花費空間去建置一個結構，這個結構通常是用B+ Tree，在這個結構中去紀錄索引值以及實際位址。這樣當我們要進行查詢時，就可以透過B+ Tree的架構特性來縮短查詢時間 O(logN)。


舉例 : 今天的Table

![123](index.png)



## 其他說明



1. 常用作排序或分組的欄位 (OrderBy, GroupBy) : 
    - order by的欄位沒有Index的情況下進行查詢，是先找出符合條件的資料、進行排序，最後傳遞。
    - order by的欄位是有index的情況下進行查詢，直接去 Index裡面查詢後就可以回傳，`省略排序`。因為Index所用的B+Tree 本身就有排序的功能。
    - 所以`常用來判斷搜尋`的欄位，都會建立index





2. PostgreSQL 使用 MVCC，更新或刪除資料時，舊版本不會立即刪除，而是標記為失效。雖然 autovacuum 定期清理部分無效資料，但無法完全壓縮索引頁面空間。
結果導致索引變得碎片化、膨脹（bloat），影響查詢效率和空間使用。

    解決方法： 使用 REINDEX，重新建立索引，整理有效資料，提高空間利用率和效能。
    檢查方法： 可透過 pg_stat_user_indexes 或 pgstatindex() 監測膨脹狀況。


3. 索引頁面空間 : B-tree 索引的Leaf Node，會被切割成多個用來存放Key + tuple identifier(TID) 每個預設為8KB的 索引頁面。這些頁面是索引實際儲存資料的基本單位。[可以想像B-tree的Leaf 被切成多個區塊，1個區塊就是一個頁面

4. 可以用EXPLAIN 查看table是如何scan的
